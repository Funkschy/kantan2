import "std/str";

import "cli/opt";
import "cli/config";
import "cli/report";

import "compiler" as _;

// for table initialization
import "ast/token";
import "error";

type ReturnCode enum {
    OK,
    NoInputFiles,
    CliOptionError,
    InvalidInput
}

def main(argc: i32, argv: *string): ReturnCode {
    if argc <= 1 {
        report.print_simple(str.view("no input files", 14));
        return ReturnCode.NoInputFiles;
    }

    init_tables();

    let opts = opt.parse(argc, argv);
    let config = config.from_options(&opts);
    defer config.free();

    let compiler = compiler(&config);
    defer compiler.free();

    // this is needed for mi mode, where errors are printed as json
    report.init(config.error_output_format, &compiler.modmap);
    defer report.finish();

    if opts.had_errors {
        return ReturnCode.CliOptionError;
    } else if opts.exit_immediately {
        return ReturnCode.OK;
    }

    if config.files.len < 1 {
        report.print_simple(str.view("no kantan files", 15));
        return ReturnCode.NoInputFiles;
    }

    compiler.read_files();
    compiler.resolve_imports();
    if compiler.parse().is_error() {
        return ReturnCode.InvalidInput;
    }

    if config.quit_after_parsing {
        if opts.dump_ast {
            dump_ast(&compiler);
        }
        return ReturnCode.OK;
    }

    // TODO: this is debug code
    import "types/types";
    import "memory/arena";

    let ty_arena = arena.typed(sizeof types.Type);
    defer ty_arena.free();
    let node_arena = arena.typed(sizeof types.TypeNode);
    defer node_arena.free();

    {
        import "types/ctx";
        import "types/check/item" as i_check;
        import "types/resolve/functions" as resolve_functions;
        import "types/info";
        import "types/primitive";

        let ctx = ctx.create(&ty_arena, &node_arena);
        defer ctx.free();

        ctx.open_scope();
        defer ctx.close_scope();

        let void_ty = ty_arena.alloc() as *types.Type;
        void_ty.kind = types.TypeKind.Void;
        ctx.bind_type_public(str.view_from("void"), void_ty, null);

        let b_ty = ty_arena.alloc() as *types.Type;
        b_ty.kind = types.TypeKind.Bool;
        ctx.bind_type_public(str.view_from("bool"), b_ty, null);

        let c_ty = ty_arena.alloc() as *types.Type;
        c_ty.init_int(primitive.Signedness.Signed, info.size_bytes(1));
        ctx.bind_type_public(str.view_from("i8"), c_ty, null);

        let isize_ty = ty_arena.alloc() as *types.Type;
        isize_ty.init_int(primitive.Signedness.Signed, info.size_bytes_platform_dependent(8));
        ctx.bind_type_public(str.view_from("isize"), isize_ty, null);

        let s_ty = ty_arena.alloc() as *types.Type;
        s_ty.init_ptr(c_ty);
        ctx.bind_type_public(str.view_from("string"), s_ty, null);

        let i32_ty = ty_arena.alloc() as *types.Type;
        i32_ty.init_int(primitive.Signedness.Signed, info.size_bytes(4));
        ctx.bind_type_public(str.view_from("i32"), i32_ty, null);

        let u32_ty = ty_arena.alloc() as *types.Type;
        u32_ty.init_int(primitive.Signedness.Unsigned, info.size_bytes(4));
        ctx.bind_type_public(str.view_from("u32"), u32_ty, null);

        let f32_ty = ty_arena.alloc() as *types.Type;
        f32_ty.init_float(info.size_bytes(4));
        ctx.bind_type_public(str.view_from("f32"), f32_ty, null);

        let f64_ty = ty_arena.alloc() as *types.Type;
        f64_ty.init_float(info.size_bytes(8));
        ctx.bind_type_public(str.view_from("f64"), f64_ty, null);

        let had_errors = false;
        for let i: usize = 0; i < compiler.modmap.len(); i += 1 {
            let mod = compiler.modmap.at(i);

            for let j: usize = 0; j < mod.num_items(); j += 1 {
                let item = mod.item_at(j);
                if resolve_functions.resolve(&ctx, item).is_error() {
                    had_errors = true;
                }
            }

            for let j: usize = 0; j < mod.num_items(); j += 1 {
                let item = mod.item_at(j);
                if i_check.check(&ctx, item).is_error() {
                    had_errors = true;
                }
            }
        }

        if had_errors {
            return ReturnCode.InvalidInput;
        }
    }

    if opts.dump_ast {
        dump_ast(&compiler);
    }

    return ReturnCode.OK;
}

def dump_ast(compiler: *Compiler) {
    // TODO: integrate this into the program in more appropriate manner
    import "io";
    io.printf("\"modules\": [");
    defer io.printf("],\n");

    for let i: usize = 0; i < compiler.modmap.len(); i += 1 {
        if i > 0 {
            io.printf(", ");
        }

        let mod = compiler.modmap.at(i);
        let json = mod.to_json();
        io.printf("%s\n", json.cstring());
        json.free();
    }
}

// Initialize global arrays
// this function should be removed, as soon as we can declare global array literals
def init_tables() {
    token.init();
    error.init();
}
