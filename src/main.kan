import "std/str";

import "cli/opt";
import "cli/config";
import "cli/report";

import "compiler" as _;

// for table initialization
import "ast/token";
import "error";

type ReturnCode enum {
    OK,
    NoInputFiles,
    CliOptionError
}

def main(argc: i32, argv: *string): ReturnCode {
    if argc <= 1 {
        report.print_simple(str.view("no input files", 14));
        return ReturnCode.NoInputFiles;
    }

    init_tables();

    let opts = opt.parse(argc, argv);
    let config = config.from_options(&opts);
    defer config.free();

    let compiler = compiler(&config);
    defer compiler.free();

    // this is needed for mi mode, where errors are printed as json
    report.init(config.error_output_format, &compiler.modmap);
    defer report.finish();

    if opts.had_errors {
        return ReturnCode.CliOptionError;
    } else if opts.exit_immediately {
        return ReturnCode.OK;
    }

    if config.files.len < 1 {
        report.print_simple(str.view("no kantan files", 15));
        return ReturnCode.NoInputFiles;
    }

    compiler.read_files();
    compiler.resolve_imports();
    compiler.parse();

    // TODO: remove this temporary code
    if opts.dump_ast {
        import "io";
        io.printf("\"modules\": [");
        defer io.printf("],\n");

        for let i: usize = 0; i < compiler.modmap.len(); i += 1 {
            if i > 0 {
                io.printf(", ");
            }

            let mod = compiler.modmap.at(i);
            let json = mod.to_json();
            io.printf("%s\n", json.cstring());
            json.free();
        }
    }

    return ReturnCode.OK;
}

// Initialize global arrays
// this function should be removed, as soon as we can declare global array literals
def init_tables() {
    token.init();
    error.init();
}
