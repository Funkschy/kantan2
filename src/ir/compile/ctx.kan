import ":std/str";
import ":std/dbg";
import ":std/vec";
import ":std/map";

import ":ast/mod";
import ":ast/item" as ast;

import ":util" as _;
import ":memory/arena";
import ":source/ident";
import ":types/types" as ty;

import "../ir";
import "../const";
import "../rvalue";
import "../memory";

import "locals";
import "escape";

type StringLiteral struct {
    value: str.String,
    next: *StringLiteral
}

def (lit: *StringLiteral) free() {
    lit.value.free();
}

type IRCtx struct {
    names: locals.NameTable,
    current_function: *ir.Function,
    functions: map.Map, // map.Map[*ir.Function], the functions are allocated in function_arena
    function_arena: *arena.TypedArena,
    string_literal_head: *StringLiteral,
    string_literal_arena: *arena.TypedArena
}

def create(
    function_arena: *arena.TypedArena,
    string_literal_arena: *arena.TypedArena,
    mod: *mod.Module
): IRCtx {
    dbg.assert(function_arena.elem_size == sizeof ir.Function, "wrong function arena size");
    dbg.assert(string_literal_arena.elem_size == sizeof StringLiteral, "wrong string_literal_arena size");

    // this is a good guess, since most of the items in a module will be functions
    let functions = map.with_cap(mod.num_items());

    for let i: usize = 0; i < mod.num_items(); i += 1 {
        let item = mod.item_at(i);
        if item.kind == ast.ItemKind.FuncDef {
            let f = &item.data.func_def;
            let function = function_arena.alloc() as *ir.Function;
            function.original_name = item.name;
            function.mangled_name = str.from("");
            function.ty = f.instances.get(0);
            function.body = ir.FunctionBody {
                blocks: vec.create(sizeof ir.BasicBlock),
                locals: vec.create(sizeof ir.LocalVarDecl)
            };

            functions.insert(key_from_ident(item.name), function as *void);
        }
    }


    return IRCtx {
        names: locals.create(),
        current_function: null,
        functions: functions,
        function_arena: function_arena,
        string_literal_head: null,
        string_literal_arena: string_literal_arena
    };
}

def (ctx: *IRCtx) free() {
    ctx.names.free();
    ctx.functions.free();
}

def (ctx: *IRCtx) set_current_function(name: ident.Ident, ty: *ty.Type) {
    ctx.names.free();
    ctx.names = locals.create();
    let function = ctx.functions.get(key_from_ident(name)) as *ir.Function;
    dbg.assert(function != null, "trying to set non existing function");

    ctx.current_function = function;
}

def (ctx: *IRCtx) push_stmt(stmt: *ir.Statement) {
    let f = ctx.current_function;
    dbg.assert(f != null, "trying to push statement without a function");

    let bb = f.current_bb();
    bb.push_stmt(stmt);
}

def (ctx: *IRCtx) push_terminator(terminator: *ir.Terminator) {
    let f = ctx.current_function;
    dbg.assert(f != null, "trying to set terminator without a function");

    f.terminate_current(terminator);
}

def (ctx: *IRCtx) declare_temp_var(ty: *ty.Type): memory.Local {
    let local = ctx.names.create_temp_var();
    ctx.current_function.body.add_local(local, ty);
    return local;
}

def (ctx: *IRCtx) declare_local(name: ident.Ident, ty: *ty.Type): memory.Local {
    let local = ctx.bind_local(name);
    ctx.current_function.body.add_local(local, ty);
    return local;
}

def (ctx: *IRCtx) bind_local(name: ident.Ident): memory.Local {
    return ctx.names.bind(name.as_view());
}

def (ctx: *IRCtx) lookup_local(name: ident.Ident, out: *memory.Local): Result {
    return ctx.names.lookup(name.as_view(), out);
}

def (ctx: *IRCtx) lookup_function(name: ident.Ident, out: *const.Constant): Result {
    let function = ctx.functions.get(key_from_ident(name)) as *ir.Function;
    if function == null {
        return Result.Error;
    }

    *out = const.function(function);
    return Result.OK;
}

def (ctx: *IRCtx) open_scope() {
    ctx.names.open_scope();
}

def (ctx: *IRCtx) close_scope() {
    ctx.names.close_scope();
}

// replace escaped chars withing the string with the correct value (e.g. \n -> 10)
// this also manages the memory automatically for the caller
def (ctx: *IRCtx) unescape_string_literal(lit: str.View): str.View {
    let raw = escape.unescape_string(lit);
    let memory = ctx.string_literal_arena.alloc() as *StringLiteral;
    memory.value = raw;
    memory.next = ctx.string_literal_head;
    ctx.string_literal_head = memory;
    return memory.value.view();
}
