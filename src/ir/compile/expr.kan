import ":std/dbg";

import ":util" as _;
import ":ast/expr" as _;

import "../ir";
import "../const";
import "../rvalue";
import "../memory";

import "call";
import "literal";
import "ctx" as _;

type CompileResult struct {
    is_error: bool,
    value: rvalue.Expression
}

def ok(value: rvalue.Expression): CompileResult {
    return CompileResult { is_error: false, value: value };
}

def error(): CompileResult {
    return CompileResult { is_error: true, value: undefined };
}

type ResultFormat enum {
    RValue, // any rvalue
    Location // a location in memory. Might create a temporary variable
}

def compile(ctx: *IRCtx, expr: *Expr): CompileResult {
    return compile_fmt(ctx, expr, ResultFormat.RValue);
}

def compile_fmt(ctx: *IRCtx, expr: *Expr, format: ResultFormat): CompileResult {
    if expr.kind == ExprKind.Literal {
        return literal.compile_fmt(ctx, expr, format);
    }

    if expr.kind == ExprKind.Assign {
        return compile_assign(ctx, expr.data.assign.left, expr.data.assign.right, format);
    }

    if expr.kind == ExprKind.Ident {
        let name = expr.data.ident.name;

        let local: memory.Local = undefined;
        if ctx.lookup_local(name, &local).is_error() {
            // if this is not a local, try looking it up in the global function table
            let function: const.Constant = undefined;
            if ctx.lookup_function(name, &function).is_error() {
                return error();
            }

            if format == ResultFormat.RValue {
                return ok(rvalue.expr_const(function));
            }

            let temp = ctx.declare_temp_var(expr.ty).as_location();
            let assign = ir.assign(temp, rvalue.expr_const(function));
            ctx.push_stmt(&assign);

            return ok(rvalue.expr_ref(temp));
        }

        let location = local.as_location();
        if format == ResultFormat.RValue {
            return ok(rvalue.expr_copy(location));
        }

        return ok(rvalue.expr_ref(location));
    }

    if expr.kind == ExprKind.Call {
        return call.compile_fmt(ctx, expr, format);
    }

    if expr.kind == ExprKind.Binary {
        return compile_binary(ctx, expr, format);
    }

    if expr.kind == ExprKind.Unary {
        let unary = &expr.data.unary;

        if unary.kind == UnaryKind.Deref {
            let location = compile_fmt(ctx, unary.right, ResultFormat.Location);
            if location.is_error {
                return location;
            }
            dbg.assert(location.value.kind == rvalue.ExpressionKind.Ref, "compile_fmt ignored format");
            let location = location.value.data.ref;

            ctx.add_projection(&location.projection_head, memory.deref());

            if format == ResultFormat.RValue {
                return ok(rvalue.expr_copy(location));
            }

            return ok(rvalue.expr_ref(location));
        }

        return error();
    }

    dbg.assert(false, "Unhandled ExprKind");
    return error();
}

def compile_binary(ctx: *IRCtx, expr: *Expr, format: ResultFormat): CompileResult {
    let binary = &expr.data.binary;
    let left = binary.left;
    let right = binary.right;
    return error();
}

// TODO: handle different assignment kinds
def compile_assign(ctx: *IRCtx, left: *Expr, right: *Expr, format: ResultFormat): CompileResult {
    // try to get the destination location for this assignment
    let dest = compile_fmt(ctx, left, ResultFormat.Location);
    if dest.is_error {
        return dest;
    }

    let dest = dest.value;
    dbg.assert(dest.kind == rvalue.ExpressionKind.Ref, "compile_fmt ignored format");
    let dest_location = dest.data.ref;

    let value = compile(ctx, right);
    if value.is_error {
        return value;
    }

    let value = value.value;
    let assign = ir.assign(dest_location, value);
    ctx.push_stmt(&assign);

    // since assignments are expressions in kantan, we need to return either the location or the
    // value of the result of the assignment
    if format == ResultFormat.Location {
        // since we just assigned the value to dest, we can just return dest
        return ok(dest);
    }

    // if the caller wants a proper rvalue, we just copy the value out of the memory location
    // where we just wrote the value
    let op = rvalue.copy(dest_location);
    return ok(rvalue.expr_use(op));
}
