import ":std/dbg";
import ":std/libc";

import ":util" as _;
import ":ast/expr" as _;

import "../ir";
import "../rvalue";
import "../memory";

import "escape";
import "ctx" as _;

type ExpressionResult struct {
    is_error: bool,
    value: rvalue.Expression
}

def ok(value: rvalue.Expression): ExpressionResult {
    return ExpressionResult { is_error: false, value: value };
}

def error(): ExpressionResult {
    return ExpressionResult { is_error: true, value: undefined };
}

type ResultFormat enum {
    RValue, // any rvalue
    Location // a location in memory. Might create a temporary variable
}

// TODO: handle different assignment kinds
def compile_assign(ctx: *IRCtx, left: *Expr, right: *Expr, format: ResultFormat): ExpressionResult {
    // try to get the destination location for this assignment
    let dest = compile_fmt(ctx, left, ResultFormat.Location);
    if dest.is_error {
        return dest;
    }

    let dest = dest.value;
    dbg.assert(dest.kind == rvalue.ExpressionKind.Ref, "compile_fmt ignored format");
    let dest_location = dest.data.ref;

    let value = compile(ctx, right);
    if value.is_error {
        return value;
    }

    let value = value.value;
    let assign = ir.assign(dest_location, value);
    ctx.push_stmt(&assign);

    // since assignments are expressions in kantan, we need to return either the location or the
    // value of the result of the assignment
    if format == ResultFormat.Location {
        // since we just assigned the value to dest, we can just return dest
        return ok(dest);
    }

    // if the caller wants a proper rvalue, we just copy the value out of the memory location
    // where we just wrote the value
    let op = rvalue.copy(dest_location);
    return ok(rvalue.expr_use(op));
}

def compile(ctx: *IRCtx, expr: *Expr): ExpressionResult {
    return compile_fmt(ctx, expr, ResultFormat.RValue);
}

def compile_fmt(ctx: *IRCtx, expr: *Expr, format: ResultFormat): ExpressionResult {
    if expr.kind == ExprKind.Literal {
        let literal = compile_literal(ctx, expr);
        if literal.is_error {
            return literal;
        }

        // the caller wants a location, so we copy the value into a temporary and return that temp
        if format == ResultFormat.Location && literal.value.kind != rvalue.ExpressionKind.Ref {
            let temp = ctx.declare_temp_var(expr.ty);
            let temp_location = temp.as_location();

            let assign = ir.assign(temp_location, literal.value);
            ctx.push_stmt(&assign);

            literal.value = rvalue.expr_ref(temp_location);
        }

        return literal;
    }

    if expr.kind == ExprKind.Assign {
        return compile_assign(ctx, expr.data.assign.left, expr.data.assign.right, format);
    }

    if expr.kind == ExprKind.Ident {
        let name = expr.data.ident.name;

        let local: memory.Local = undefined;
        if ctx.lookup_local(name, &local).is_error() {
            // if this is not a local, try looking it up in the global function table
            let function: rvalue.Constant = undefined;
            if ctx.lookup_function(name, &function).is_error() {
                return error();
            }

            if format == ResultFormat.RValue {
                return ok(rvalue.expr_const(function));
            }

            let temp = ctx.declare_temp_var(expr.ty).as_location();
            let assign = ir.assign(temp, rvalue.expr_const(function));
            ctx.push_stmt(&assign);

            return ok(rvalue.expr_ref(temp));
        }

        let location = local.as_location();
        if format == ResultFormat.RValue {
            return ok(rvalue.expr_copy(location));
        }

        return ok(rvalue.expr_ref(location));
    }

    if expr.kind == ExprKind.Call {
        let call_expr = &expr.data.call;
        let callee = compile(ctx, call_expr.callee);
        if callee.is_error {
            return callee;
        }

        let callee = callee.value;
        dbg.assert(
            callee.kind == rvalue.ExpressionKind.Ref || callee.kind == rvalue.ExpressionKind.Use,
            "compile_fmt ignored format"
        );

        let callee_op: rvalue.Operand = undefined;
        if callee.kind == rvalue.ExpressionKind.Ref {
            callee_op = rvalue.copy(callee.data.ref);
        } else {
            callee_op = callee.data.use;
        }

        // TODO(#45): compile args

        let dest = ctx.declare_temp_var(expr.ty).as_location();
        let call = ir.call(callee_op, null, dest);
        ctx.push_terminator(&call);

        if format == ResultFormat.RValue {
            return ok(rvalue.expr_copy(dest));
        }

        return ok(rvalue.expr_ref(dest));
    }

    // dbg.assert(false, "Unhandled StmtKind");
    return error();
}

def compile_literal(ctx: *IRCtx, expr: *Expr): ExpressionResult {
    let lit = &expr.data.lit;
    if lit.kind == LiteralKind.Undefined {
        let constant = rvalue.const_undefined(expr.ty);
        let undef = rvalue.expr_const(constant);
        return ok(undef);
    }

    if lit.kind == LiteralKind.Null {
        let constant = rvalue.const_null(expr.ty);
        let nil = rvalue.expr_const(constant);
        return ok(nil);
    }

    if lit.kind == LiteralKind.DecInt || lit.kind == LiteralKind.HexInt {
        let base = 10 + 6 * ((lit.kind == LiteralKind.HexInt) as u32);

        let value = int_from_view(lit.token.span.as_view(), base);
        let constant = rvalue.const_int(expr.ty, value);
        let int = rvalue.expr_const(constant);
        return ok(int);
    }

    if lit.kind == LiteralKind.Float {
        let value = libc.strtod(lit.token.span.start, null);
        let constant = rvalue.const_float(expr.ty, value);
        let float = rvalue.expr_const(constant);
        return ok(float);
    }

    if lit.kind == LiteralKind.Char {
        let value = *lit.token.span.start;
        if value == '\\' {
            value = escape.char_literal(*(lit.token.span.start + 1));
        }
        let constant = rvalue.const_char(expr.ty, value);
        let char = rvalue.expr_const(constant);
        return ok(char);
    }

    return error();
}
