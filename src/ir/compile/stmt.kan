import ":std/dbg";

import ":util" as _;
import ":ast/stmt" as _;
import ":ast/expr" as e;
import ":types/types" as ty;

import "../ir";
import "../const";
import "../rvalue";

import "ctx" as _;
import "expr";

def compile(ctx: *IRCtx, stmt: *Stmt): Result {
    if stmt.kind == StmtKind.LocalVarDecl {
        let decl = &stmt.data.local;

        let local = ctx.declare_local(decl.name, decl.value.ty).as_location();
        let value = expr.compile(ctx, decl.value);
        if value.is_error {
            return Result.Error;
        }

        let assign = ir.assign(local, value.value);
        ctx.push_stmt(&assign);

        return Result.OK;
    }

    if stmt.kind == StmtKind.Expr {
        let value = expr.compile(ctx, &stmt.data.expr);
        if value.is_error {
            return Result.Error;
        }

        // every value in the ir must be assigned to something, so if there is no assignment
        // in the source code, we just assigne the value to a temporary
        if stmt.data.expr.kind != e.ExprKind.Assign {
            let temp = ctx.declare_temp_var(stmt.data.expr.ty).as_location();
            let assign = ir.assign(temp, value.value);
            ctx.push_stmt(&assign);
        }

        return Result.OK;
    }

    if stmt.kind == StmtKind.Block {
        let block = &stmt.data.block;

        ctx.open_scope();
        defer ctx.close_scope();

        let had_errors = false;
        for let i: usize = 0; i < block.len(); i += 1 {
            had_errors |= compile(ctx, block.at(i)).is_error();
        }

        if had_errors {
            return Result.Error;
        }

        return Result.OK;
    }

    if stmt.kind == StmtKind.Return {
        let return_type = ctx.current_function.return_type();
        let value: rvalue.Operand = undefined;

        if return_type.kind == ty.TypeKind.Void {
            value = rvalue.const(const.nothing(return_type));
        } else {
            let return_value = expr.compile_fmt(ctx, stmt.data.ret, expr.ResultFormat.Location);
            if return_value.is_error {
                return Result.Error;
            }
            let return_location = return_value.value.data.ref;

            value = rvalue.copy(return_location);
        }

        let ret = ir.ret(value);
        ctx.push_terminator(&ret);
        return Result.OK;
    }

    dbg.assert(false, "Unhandled StmtKind");
    return Result.Error;
}
