import ":std/vec";
import ":std/dbg";
import ":std/str";

import ":source/ident";
import ":types/types" as ty;

import "rvalue";
import "memory";

// Statements
type StatementKind enum {
    Assign, Nop
}

type Statement struct {
    kind: StatementKind,
    data: StatementData
}

type StatementData union {
    // nop does not need any data
    assign: Assign
}

def assign(location: memory.Location, value: rvalue.Expression): Statement {
    return Statement {
        kind: StatementKind.Assign,
        data: StatementData {
            assign: Assign {
                location: location,
                value: value
            }
        }
    };
}

type Assign struct {
    location: memory.Location,
    value: rvalue.Expression
}

// Terminators

// TODO: the current test cases actually check for Nop terminator, which is very much wrong
type TerminatorKind enum {
    Nop, // this should only be set during compilation. It is not a valid Terminator!
    Return, Call, Jmp
}

type Terminator struct {
    kind: TerminatorKind,
    data: TerminatorData
}

type TerminatorData union {
    call: Call,
    ret: rvalue.Operand // the return value. const nothing for void functions
}

type Call struct {
    callee: rvalue.Operand,
    args_head: *rvalue.OperandNode,
    // the return value of this call will be written to dest
    dest: memory.Location,
    next: usize // the id of the next basic block
}

def call(callee: rvalue.Operand, args_head: *rvalue.OperandNode, dest: memory.Location): Terminator {
    return Terminator {
        kind: TerminatorKind.Call,
        data: TerminatorData {
            call: Call {
                callee: callee,
                args_head: args_head,
                dest: dest,
                next: 0 // this is filled when we actually terminate the block
            }
        }
    };
}

def ret(value: rvalue.Operand): Terminator {
    return Terminator {
        kind: TerminatorKind.Return,
        data: TerminatorData {
            ret: value
        }
    };
}

type BasicBlock struct {
    statements: vec.Vec, // vec.Vec[Statement]
    terminator: Terminator
}

def basic_block(): BasicBlock {
    return BasicBlock {
        statements: vec.create(sizeof Statement),
        terminator: Terminator {
            kind: TerminatorKind.Nop,
            data: undefined
        }
    };
}

def (bb: *BasicBlock) free() {
    bb.statements.free();
}

def (bb: *BasicBlock) push_stmt(stmt: *Statement) {
    bb.statements.push(stmt as *void);
}

def (bb: *BasicBlock) terminate(terminator: *Terminator) {
    bb.terminator = *terminator;
}

type Function struct {
    original_name: ident.Ident,
    mangled_name: str.String,
    ty: *ty.Type,
    body: FunctionBody
}

def (f: *Function) free() {
    f.mangled_name.free();
    f.body.free();
}

def (f: *Function) return_type(): *ty.Type {
    return f.ty.data.function.ret;
}

def (f: *Function) current_bb(): *BasicBlock {
    // if there is no block, just open one
    if f.body.blocks.len == 0 {
        let bb = basic_block();
        f.body.blocks.push(&bb as *void);
    }

    return f.body.blocks.get_ptr(f.body.blocks.len - 1) as *BasicBlock;
}

def (f: *Function) terminate_current(terminator: *Terminator) {
    if terminator.kind == TerminatorKind.Call {
        terminator.data.call.next = f.body.blocks.len;
    }

    f.current_bb().terminate(terminator);
    let new_bb = basic_block();
    f.body.blocks.push(&new_bb as *void);
}

type FunctionBody struct {
    blocks: vec.Vec, // vec.Vec[BasicBlock]
    locals: vec.Vec  // vec.Vec[LocalVarDecl] (indexed by memory.Local)
}

def (b: *FunctionBody) free() {
    for let i: usize = 0; i < b.blocks.len; i += 1 {
        let bb = b.blocks.get_ptr(i) as *BasicBlock;
        bb.free();
    }
    b.blocks.free();
    b.locals.free();
}

def (b: *FunctionBody) add_local(local: memory.Local, ty: *ty.Type) {
    let decl = LocalVarDecl { ty: ty };
    b.locals.push(&decl as *void);
    dbg.assert(b.locals.len == local.idx, "inconsistent locals");
}

type LocalVarDecl struct {
    ty: *ty.Type
}

// json generation stuff

def (f: *Function) to_json(): str.String {
    let json = str.from("{");
    defer json.push(str.view("}", 1));

    json.push(str.view_from("\"original_name\": \""));
    json.push(f.original_name.as_view());
    json.push(str.view_from("\""));

    json.push(str.view_from(", \"locals\": ["));
    for let i: usize = 0; i < f.body.locals.len; i += 1 {
        if i > 0 {
            json.push(str.view(", ", 2));
        }

        let l = f.body.locals.get_ptr(i) as *LocalVarDecl;
        json.push(str.view_from("{\"name\": \""));
        defer json.push(str.view("}", 1));

        // locals start at 1
        let name = memory.local(1 + i).to_string();
        json.push(name.view());
        name.free();

        json.push(str.view_from("\", \"type\": \""));
        let ty_s = l.ty.to_string();
        json.push(ty_s.view());
        ty_s.free();
        json.push(str.view("\"", 1));
    }
    json.push(str.view("]", 1));

    json.push(str.view_from(", \"blocks\": {"));
    for let i: usize = 0; i < f.body.blocks.len; i += 1 {
        let bb = f.body.blocks.get_ptr(i) as *BasicBlock;
        if bb.statements.len == 0 {
            dbg.assert(i == f.body.blocks.len - 1, "empty bb in middle of ir");
            break;
        }

        if i > 0 {
            json.push(str.view(", ", 2));
        }

        json.push(str.view_from("\"bb"));
        let number = str.i64_to_string(i as i64);
        json.push(number.view());
        number.free();
        json.push(str.view_from("\": "));

        json.push(str.view_from("{\"statements\": ["));
        defer json.push(str.view("}", 1));

        for let j: usize = 0; j < bb.statements.len; j += 1 {
            if j > 0 {
                json.push(str.view(", ", 2));
            }

            let s = bb.statements.get_ptr(j) as *Statement;
            let s_json = s.to_json();
            json.push(s_json.view());
            s_json.free();
        }
        json.push(str.view("]", 1));

        json.push(str.view_from(", \"terminator\": "));
        let terminator_json = bb.terminator.to_json();
        json.push(terminator_json.view());
        terminator_json.free();
    }
    json.push(str.view("}", 1));

    return json;
}

def (s: *Statement) to_json(): str.String {
    if s.kind == StatementKind.Assign {
        let json = str.from("{\"kind\": ");
        defer json.push(str.view_from("}"));
        json.push(str.view_from("\"assignment\""));

        json.push(str.view_from(", \"location\": "));
        let location = s.data.assign.location.to_json();
        json.push(location.view());
        location.free();

        json.push(str.view_from(", \"value\": "));
        let value = s.data.assign.value.to_json();
        json.push(value.view());
        value.free();

        return json;
    }

    dbg.assert(false, "Unhandled StmtKind");
    return str.from("");
}

def (t: *Terminator) to_json(): str.String {
    let json = str.from("{\"kind\": ");
    defer json.push(str.view_from("}"));

    if t.kind == TerminatorKind.Nop {
        json.push(str.view_from("\"nop\""));
        return json;
    }

    if t.kind == TerminatorKind.Return {
        json.push(str.view_from("\"return\", \"operand\": "));

        let value = t.data.ret.to_json();
        json.push(value.view());
        value.free();

        return json;
    }

    if t.kind == TerminatorKind.Call {
        json.push(str.view_from("\"call\", \"callee\": "));
        let callee = t.data.call.callee.to_json();
        json.push(callee.view());
        callee.free();

        json.push(str.view_from(", \"args\": ["));
        let arg = t.data.call.args_head;
        while arg != null {
            if arg != t.data.call.args_head {
                json.push(str.view(", ", 2));
            }
            let arg_json = arg.value.to_json();
            json.push(arg_json.view());
            arg_json.free();
            arg = arg.next;
        }
        json.push(str.view("]", 1));

        json.push(str.view_from(", \"dest\": "));
        let dest = t.data.call.dest.to_json();
        json.push(dest.view());
        dest.free();

        json.push(str.view_from(", \"next\": \"bb"));
        let number = str.i64_to_string(t.data.call.next as i64);
        json.push(number.view());
        number.free();
        json.push(str.view_from("\""));

        return json;
    }

    dbg.assert(false, "Unhandled TerminatorKind");
    return json;
}
