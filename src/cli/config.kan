import "opt";

import "../std/files/path";
import "../codegen/target";
import "../std/ptrvec";
import "../std/libc";
import "../std/str";

extern def get_sys(linux: *bool, darwin: *bool, win32: *bool);

type TargetConfig struct {
    ptr_width_bytes: usize,
    arch: target.Arch,
    vendor: target.Vendor,
    sys: target.Sys,
    abi: target.Abi
}

type OutputKind enum {
    ASM, OBJ, EXE
}

type ErrorOutputFormat enum {
    HumanReadable, JSON
}

type Config struct {
    emit_debug_info: bool,
    invoke_linker: bool,
    quit_after_parsing: bool,
    output_kind: OutputKind,
    error_output_format: ErrorOutputFormat,
    opt_level: i8,
    output_file: path.Path,
    temp_output_file: path.Path,
    files: ptrvec.Vec,
    target: TargetConfig
}

def (c: *Config) free() {
    c.files.free();
}

def fill_os_info(options: *opt.Options, config: *TargetConfig): bool {
    let linux = false;
    let darwin = false;
    let win32 = false;

    get_sys(&linux, &darwin, &win32);

    if options.target_os.len == 0 {
        if darwin {
            config.sys = target.Sys.Darwin;
            config.vendor = target.Vendor.Apple;
            config.abi = target.Abi.Empty;
            return true;
        }

        config.vendor = target.Vendor.PC;
        if linux {
            config.sys = target.Sys.Linux;
            config.abi = target.Abi.Gnu;
            return true;
        }

        if win32 {
            config.sys = target.Sys.Win32;
            config.abi = target.Abi.Msvc;
            return true;
        }
    }

    if options.target_os.eq(str.view_from("darwin")) {
        config.sys = target.Sys.Darwin;
        config.vendor = target.Vendor.Apple;
        config.abi = target.Abi.Empty;
        return darwin;
    }

    config.vendor = target.Vendor.PC;
    if options.target_os.eq(str.view_from("linux")) {
        config.sys = target.Sys.Linux;
        config.abi = target.Abi.Gnu;
        return linux;
    }

    if options.target_os.eq(str.view_from("win32")) {
        config.sys = target.Sys.Win32;
        config.abi = target.Abi.Msvc;
        return win32;
    }

    return false;
}

def from_options(options: *opt.Options): Config {
    let target_conf: TargetConfig = undefined;
    target_conf.ptr_width_bytes = sizeof *void;
    target_conf.arch = target.Arch.X86_64;
    let is_same_target_as_os = fill_os_info(options, &target_conf);

    // TODO(#3): support proper cross compilation for architecture
    if options.target_arch.len != 0 && options.target_arch.eq(str.view_from("wasm32")) {
        is_same_target_as_os = false;
        target_conf.ptr_width_bytes = 4;
        target_conf.arch = target.Arch.Wasm32;
        target_conf.vendor = target.Vendor.None;
        target_conf.sys = target.Sys.None;
        target_conf.abi = target.Abi.None;
    }

    let out_name = "out.o";
    let out_len: usize = 5;
    let gen_asm = false;
    let gen_obj = false;

    let temp_out = path.create_l(out_name, out_len);

    let output_filename = options.output_filename;
    if output_filename.len != 0 {
        let len = output_filename.len;
        if len >= 3 {
            gen_asm = output_filename.drop(len - 2).eq(str.view(".s", 2));
            gen_obj = output_filename.drop(len - 2).eq(str.view(".o", 2));
        }

        out_name = output_filename.data;
        out_len = len;

        if gen_asm || gen_obj {
            temp_out = path.create_l(out_name, out_len);
        }
    } else {
        // the default executable name
        out_name = "a.out";
        out_len = 5;
    }

    // we currently use the system linker, which ofc only works on the same system
    let invoke_linker = !(gen_asm || gen_obj) && is_same_target_as_os;
    let out = path.create_l(out_name, out_len);

    let kind = OutputKind.EXE;
    if gen_asm {
        kind = OutputKind.ASM;
    } else if gen_obj {
        kind = OutputKind.OBJ;
    }

    let error_output_format = ErrorOutputFormat.HumanReadable;
    if options.output_json {
        error_output_format = ErrorOutputFormat.JSON;
    }

    return Config {
        emit_debug_info: options.debug_info,
        invoke_linker: invoke_linker,
        quit_after_parsing: options.parse_only,
        output_kind: kind,
        error_output_format: error_output_format,
        opt_level: options.opt_level,
        output_file: out,
        temp_output_file: temp_out,
        files: options.files,
        target: target_conf
    };
}
