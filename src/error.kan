import "std/str";
import "cdeps";

import "source/span";

let error_strings: [4]string = undefined;

type ErrorKind enum {
    // import errors
    CouldNotImport,
    SelfImport,
    // parse errors
    ExpectedButGot,
    UnknownToken
}

type ErrorDataKind enum {
    NoAdditionalData,
    StringSingle,
    StringTuple
}

type Error struct {
    kind: ErrorKind,
    data_kind: ErrorDataKind,
    note: *ErrorNote,
    span: span.Span,
    data: ErrorData
}

def (e: *Error) fmt_string(): string {
    return error_strings[e.kind as i32];
}

def (e: *Error) to_string(): str.String {
    let len: usize = 0;
    let value: string = null;

    if e.data_kind == ErrorDataKind.NoAdditionalData {
        return str.from(e.fmt_string());
    }

    if e.data_kind == ErrorDataKind.StringSingle {
        let str = e.data.string_single;
        value = cdeps.l_format_str(
            &len,
            e.fmt_string(),
            str.len, str.data
        );
    } else if e.data_kind == ErrorDataKind.StringTuple {
        let first = e.data.string_tuple.first;
        let second = e.data.string_tuple.second;
        value = cdeps.l_format_str(
            &len,
            e.fmt_string(),
            first.len, first.data,
            second.len, second.data
        );
    }

    return str.move_l(value, len);
}

def (e: *Error) add_note(note: *ErrorNote) {
    if e.note == null {
        e.note = note;
        return;
    }

    let last = e.note;
    while last.next != null {
        last = last.next;
    }

    last.next = note;
}

def simple_error(kind: ErrorKind, span: span.Span): Error {
    return Error {
        kind: kind,
        data_kind: ErrorDataKind.NoAdditionalData,
        note: null,
        span: span,
        data: undefined
    };
}

def string_single(kind: ErrorKind, span: span.Span, str: str.View): Error {
    return Error {
        kind: kind,
        data_kind: ErrorDataKind.StringSingle,
        note: null,
        span: span,
        data: ErrorData { string_single: str }
    };
}

def string_tuple(kind: ErrorKind, span: span.Span, first: str.View, second: str.View): Error {
    return Error {
        kind: kind,
        data_kind: ErrorDataKind.StringTuple,
        note: null,
        span: span,
        data: ErrorData { string_tuple: StringTuple { first: first, second: second } }
    };
}

type ErrorData union {
    string_single: str.View,
    string_tuple: StringTuple
}

type StringTuple struct {
    first: str.View,
    second: str.View
}

def init() {
    error_strings[0] = "Invalid import: %.*s";
    error_strings[1] = "Modules cannot import themselves";
    // parse errors
    error_strings[2] = "Expected '%.*s', but got '%.*s'";
    error_strings[3] = "Unknown token '%.*s'";
}

// A Linked List of additional information regarding an error, e.g. the location of usage
// the function which adds the notes is also responsible for freeing them
type ErrorNote struct {
    // if this is true, it means that the span field must be ignored, because this is just a simple
    // string message without any associated source file or position
    without_position: bool,
    message: str.View,
    span: span.Span,
    next: *ErrorNote
}

def note(message: str.View, span: span.Span): ErrorNote {
    return ErrorNote { without_position: false, message: message, span: span, next: null };
}

def simple_note(message: str.View): ErrorNote {
    return ErrorNote { without_position: true, message: message, span: span.empty(), next: null };
}
