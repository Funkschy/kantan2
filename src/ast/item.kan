import "../std/str";

import "../source/span";
import "../source/ident";

import "stmt";
import "signature" as sig;

// Import declarations aren't Items, since they cannot occur at an arbitrary position inside
// the file. All imports have to be decared at the top of the file, before any other ast.Item
// This makes it easy to determine the dependencies of a single module before we even parse the
// entire file.
type ImportDeclaration struct {
    path: ident.Ident,
    alias: ident.Ident
}

type ItemKind enum {
    FuncDef
}

// a single item inside the ast. Items can occur at an arbitrary place inside a module, including
// the top level
type Item struct {
    kind: ItemKind,
    span: span.Span,
    // the name of the item or ident.empty() for nameless items
    name: ident.Ident,
    data: ItemData
}

type ItemData union {
    func_def: FuncDef
}

def (i: *Item) init_func_def() {
    i.kind = ItemKind.FuncDef;
    i.data.func_def.sig.init();
    i.data.func_def.block.init();
}

def (i: *Item) free() {
    if i.kind == ItemKind.FuncDef {
        i.data.func_def.free();
    }
}

type FuncDef struct {
    sig: sig.Signature,
    block: stmt.Block
}

def (f: *FuncDef) free() {
    f.sig.free();
    f.block.free();
}

def (i: *Item) to_json(): str.String {
    if i.kind == ItemKind.FuncDef {
        let json = str.from("{\"kind\": \"func_def\", \"body\": ");
        let inner = i.data.func_def.block.to_json();
        defer inner.free();
        json.push(inner.view());
        json.push(str.view_from("}"));
        return json;
    }

    return str.from("{\"kind\": \"error\", \"value\": {}}");
}
