import "std/str";
import "std/dbg";
import "std/files/path";

import "ast/mod";
import "ast/tyid";
import "ast/item";
import "ast/lexer" as lex;
import "ast/parser" as parse;

import "cli/config";
import "cli/report";

import "memory/arena";
import "source/span";
import "source/modmap" as mods;

import "error" as e;
import "util" as _;

// the main data structure for the compiler
// this holds all of the memory for types and the ast
type Compiler struct {
    cwd: path.Buf,
    config: *config.Config,
    modmap: mods.Map,
    mod_arena: arena.TypedArena,
    ast_arena: arena.TypedArena,
    ty_arena: arena.TypedArena
}

def compiler(config: *config.Config): Compiler {
    return Compiler {
        cwd: path.get_cwd(),
        config: config,
        modmap: mods.filemap(),
        mod_arena: arena.typed(sizeof mod.Module),
        ast_arena: arena.typed(sizeof item.Item),
        ty_arena: arena.typed(sizeof tyid.Type)
    };
}

def (c: *Compiler) read_files() {
    for let i: usize = 0; i < c.config.files.len; i += 1 {
        let filepath = path.create(c.config.files.get(i) as string);
        c.add_file(filepath, null);
    }
}

// try to add a single file to the modmap
// it is also possible to supply an error note which will be displayed in case the file
// could not be added
def (c: *Compiler) add_file(filepath: path.Path, note: *e.ErrorNote): Result {
    let cwd = c.cwd.as_path();
    let mod = c.mod_arena.alloc() as *mod.Module;
    mod.init(false);

    c.modmap.add_file(cwd, filepath, mod);

    if mod.file.is_error() {
        report.print_file_error(&mod.file, note);
        mod.free();
        return Result.Error;
    }

    return Result.OK;
}

def (c: *Compiler) resolve_imports() {
    for let i: usize = 0; i < c.modmap.len(); i += 1 {
        let mod = c.modmap.at(i);

        let lexer = lex.create(mod.file.code());
        let parser = parse.create(lexer, &c.ast_arena, &c.ty_arena);

        // we iterate over all the imports first, since they need to be at the top of the file
        // while resolving the imports, we keep track of all imported modules
        let parsed_import = parser.parse_next_import();
        while parsed_import.is_present || parsed_import.was_error {
            defer parsed_import = parser.parse_next_import();

            if parsed_import.was_error {
                // we don't want to quit on an erroneous import, since we want to try to
                // report all errors
                continue;
            }

            let decl = &parsed_import.import_decl;

            // imports are resolved relative to the current file by default
            let relative_to = mod.file.absolute_path().parent();
            let imported_path = path.from_view(decl.path.as_view());

            // try to resolve the imported path relative to the parent of the current file, so
            // e.g. if we are in /etc/test.kan and import "../root", we will try to
            // resolve /root.kan
            let full_imported_path: path.Buf = undefined;
            let result = relative_to.merge_abs_rel_suffix(&imported_path, ".kan", &full_imported_path);
            if result.is_error() {
                report_import_error(result, relative_to, imported_path, decl.path.span);
                continue;
            }
            // only free this, if the result was no error
            defer full_imported_path.free();

            let full_imported_path = full_imported_path.as_path();
            let imported_module = c.modmap.get_mod(full_imported_path);
            if imported_module == null {
                // an additional note to produce a better error message in case we could not add
                // the module
                let note = e.note(str.view("imported here", 13), decl.path.span);

                // try to add the imported file to the modmap, if this fails, we bail
                if c.add_file(full_imported_path, &note).is_error() {
                    continue;
                }

                imported_module = c.modmap.get_mod(full_imported_path);
                // this shouldn't happen, since we should've bailed if the file couldn't be added
                dbg.assert(imported_module != null, "internal modmap error");
            }

            // at this point we can be sure, that the module does exist and was added to the modmap
            // so we can mark it as imported
            // all modules, that were never imported (apart from the main module) are removed before
            // type checking
            c.modmap.mark_imported(full_imported_path);

            // check for self import
            // import cycles are actually allowed, so this wouldn't be a real issue, but since
            // a self import is never needed, we report an error anyway
            if imported_module == mod {
                let error = e.simple_error(e.ErrorKind.SelfImport, decl.path.span);
                report.print_error(&error);
                continue;
            }
        }

        // at this point all legal imports have been parsed. If we encounter any more, they will
        // be reported as parse errors

        while !parser.is_at_end() {
            let parsed_item = parser.parse_item();
            if parsed_item != null {
                mod.items.push_ptr(parsed_item as *void);
            }
        }
    }

    // while resolving the imports, we keep track of the modules, that were actually imported
    // everything else (apart from the main module) can be removed to increase performance
}

def report_import_error(
    result: path.Result,
    relative_to: path.Path,
    imported_path: path.Path,
    span: span.Span
) {
    let error_msg = result.to_string(imported_path);
    defer error_msg.free();

    let error = e.string_single(e.ErrorKind.CouldNotImport, span, error_msg.view());

    let note_string = str.from("");
    defer note_string.free();

    let note: e.ErrorNote = undefined;
    // in this case, we add an additional note, to make it clear, which path was actually searched
    if result == path.Result.FileNotFound {
        note_string.push(str.view("the resolved path was '", 23));
        note_string.push(relative_to.as_view());
        note_string.push(imported_path.as_view());
        note_string.push(str.view(".kan'", 5));
        note = e.simple_note(note_string.view());
        error.note = &note;
    }

    report.print_error(&error);
}

def (c: *Compiler) free() {
    c.cwd.free();
    c.modmap.free();

    c.mod_arena.free();
    c.ast_arena.free_destructor(&item.Item.free as arena.Destructor);
    c.ty_arena.free_destructor(&tyid.Type.free as arena.Destructor);
}
