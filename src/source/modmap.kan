import "../std/str";
import "../std/dbg";
import "../std/vmap";
import "../std/files/path";

import "../ast/mod";
import "../util";

import "file" as sf; // source/file
import "span";

type ModuleInfo struct {
    was_imported: bool,
    module: *mod.Module
}

type Map struct {
    // this has to be a vmap, since we want to mutate it, while iterating. That is not something
    // that the normal map.Map supports, but the vmap can be iterated in order, while appending
    // further modules at the end
    files: vmap.Map // vmap.Map[path.Path, ModuleInfo]
}

def filemap(): Map {
    return Map { files: vmap.create(sizeof ModuleInfo) };
}

// add a file the the filemap. The relative_path is resolved in relation to the current working
// directory (cwd)
// if the file could be read, the file will inserted into the map
// if an error occured during file reading, the file will not be inserted
// The dest_mod.file is set in any case and must be checked for file.is_error() by the caller
def (m: *Map) add_file(cwd: path.Path, relative_path: path.Path, dest_mod: *mod.Module) {
    let file = sf.read_kantan_file(cwd, relative_path);
    dest_mod.file = file;

    if !file.is_error() {
        let info = ModuleInfo { was_imported: false, module: dest_mod };
        m.files.insert(util.key_from_path(file.absolute_path()), &info as *void);
    }
}

def (m: *Map) get_mod_from_span(span: span.Span): *mod.Module {
    for let i: usize = 0; i < m.files.len(); i += 1 {
        let mod = m.at(i);
        let code = mod.file.code();
        if span.start >= code.data && span.end <= code.data + code.len {
            return mod;
        }
    }

    return null;
}

def (m: *Map) len(): usize {
    return m.files.len();
}

def (m: *Map) mark_imported(path: path.Path) {
    let info = m.files.get_ptr(util.key_from_path(path)) as *ModuleInfo;
    dbg.assert(info != null, "trying to mark non existing module");
    info.was_imported = true;
}

def (m: *Map) get_mod(path: path.Path): *mod.Module {
    let info = m.files.get_ptr(util.key_from_path(path)) as *ModuleInfo;
    if info == null {
        return null;
    }
    return info.module;
}

def (m: *Map) at(idx: usize): *mod.Module {
    let info = m.files.get_ptr_idx(idx) as *ModuleInfo;
    if info == null {
        return null;
    }
    return info.module;
}

def (m: *Map) free() {
    for let i: usize = 0; i < m.files.len(); i += 1 {
        m.at(i).free();
    }
    m.files.free();
}
