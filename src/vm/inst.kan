type Inst enum {
    Nop,
    Halt,

    // alloclocals space
    // allocates stackspace for local variables, which work differently from the operand stack,
    // because they need to be aligned to their respective variable sizes while the operand stack
    // is always aligned to 8 bytes
    // e.g. if we have the locals: i32, *i32, i32
    // this will allocate 24 bytes, since the *i32 needs padding to be 8 aligned and there needs
    // to be padding after the last i32, to ensure the operand stack is 8 byte aligned
    AllocLocals,
    // localptr offset
    // push(vm.bp + offset)
    LocalPtr,

    // constww constant
    // push a iww following this instruction onto the stack
    ConstI8,
    ConstI16,
    ConstI32,
    ConstI64,

    // push_i64(pop_i64() + pop_i64())
    IAdd,

    // loadww
    // push_uww(*pop_usize())
    Load8,
    Load16,
    Load32,
    Load64,

    // storeww
    // *pop_ptr() = pop_uww()
    Store8,
    Store16,
    Store32,
    Store64
}

def with_size(start: Inst, bits: usize): Inst {
    let i_start = start as i32;
    if bits == 16 {
        i_start += 1;
    } else if bits == 32 {
        i_start += 2;
    } else if bits == 64 {
        i_start += 3;
    }

    return *(&i_start as *Inst);
}

def (i: Inst) _param_size_bytes(start: Inst, end: Inst): usize {
    if i >= start && i <= end {
        return 4 << (1 + i as i32 as usize - start as i32 as usize) >> 3;
    }

    return 0;
}

def (i: Inst) width_bytes(): usize {
    let w: usize = 1;
    w += i._param_size_bytes(Inst.ConstI8, Inst.ConstI64);
    w += (i == Inst.AllocLocals) as usize * 4;
    w += (i == Inst.LocalPtr) as usize * 4;
    return w;
}
