import "impl";
import "path";

import "../libc";

let system_separator: i8  = 47; // '/'

extern def getcwd(buf: string, buf_size: usize): string;
extern def realpath(path: string, resolved: string): string;

def init_impl(impl_functions: *[5]*void) {
    (*impl_functions)[impl.PathMethods.LastSeparatorPtr as i32] = &last_separator_ptr as *void;
    (*impl_functions)[impl.PathMethods.IsAbs as i32] = &is_abs as *void;
    (*impl_functions)[impl.PathMethods.IsRoot as i32] = &is_root as *void;
    (*impl_functions)[impl.PathMethods.Canonicalize as i32] = &canonicalize as *void;
    (*impl_functions)[impl.PathMethods.GetCwd as i32] = &get_cwd as *void;
    (*impl_functions)[impl.PathMethods.SystemSeparator as i32] = &get_separator as *void;
}

def get_separator(): i8 {
    return system_separator;
}

def last_separator_ptr(p: *path.Path): string {
    let ptr = p.inner + p.len - 1;
    while ptr > p.inner {
        ptr = ptr - 1;
        if *ptr == system_separator {
            return ptr;
        }
    }

    return null;
}

def is_abs(p: *path.Path): bool {
    return *p.inner == system_separator || *p.inner == '~';
}

def is_root(p: *path.Path): bool {
    return is_abs(p) && libc.strlen(p.inner) == 1;
}

//  this functions uses the posix only "realpath" function
// this function resolves stuff like .. or . in place
def canonicalize(p: *path.Path, dest: *path.Buf): path.Error {
    let buf = libc.strndup(p.inner, p.len);
    let real = realpath(buf, null);
    delete buf;

    if real == null {
        return path.Error.CouldNotOpenFile;
    }

    *dest = path.create_buf(real);
    return path.Error.OK;
}

def get_cwd(): path.Buf {
    let buf_size: usize = 255;
    let buf = libc.malloc(buf_size * sizeof i8) as string;

    if getcwd(buf, buf_size) == null {
        delete buf;
        return path.empty().to_buf();
    }

    return path.create_buf(buf);
}

