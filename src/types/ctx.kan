import ":std/dbg";
import ":std/map";
import ":std/str";

import ":ast/tyid";
import ":util" as _;
import ":source/span";
import ":memory/arena";

import ":error" as e;
import ":cli/report" as report;

import "util";
import "scope";

import "info" as _;
import "types" as _;

import "function";
import "template";
import "primitive";

// the context used while type checking
type TyCtx struct {
    ty_arena: *arena.TypedArena,
    node_arena: *arena.TypedArena,

    // this holds the types of lvalues, for later lookup by name
    values: scope.ScopeStack,
    // this holds declared types, e.g. structs
    types: scope.ScopeStack,

    // the current function or null, if in global scope
    current_function: *Type
}

def create(ty_arena: *arena.TypedArena, node_arena: *arena.TypedArena): TyCtx {
    dbg.assert(ty_arena.elem_size == sizeof Type, "invalid memory ty_arena");
    dbg.assert(node_arena.elem_size == sizeof TypeNode, "wrong type node arena size");

    return TyCtx {
        ty_arena: ty_arena,
        node_arena: node_arena,
        values: scope.scope_stack(),
        types: scope.scope_stack(),
        current_function: null
    };
}

def (ctx: *TyCtx) free() {
    ctx.values.free();
    ctx.types.free();
}

def (ctx: *TyCtx) open_scope() {
    ctx.values.open();
    ctx.types.open();
}

def (ctx: *TyCtx) perform_item_close(ty: *Type, declared_at: *span.Span): Result {
    // deref the type to the most basic level
    while true {
        if ty.kind == TypeKind.Variable {
            // TODO(#21): is there any way to produce cycles here?
            *ty = *ty.data.inner;
        } else if ty.kind == TypeKind.Ptr {
            ty = ty.data.ptr_to;
        } else {
            break;
        }
    }

    if ty.kind == TypeKind.AnyInt {
        // convert anyInt to i32
        ty.init_int(primitive.Signedness.Signed, size_bytes(4));
    }

    if ty.kind == TypeKind.AnyFloat {
        // convert anyFloat to f32
        ty.init_float(size_bytes(4));
    }

    // a type that could not be inferred is considered an error
    if ty.kind == TypeKind.Any {
        if declared_at == null {
            let msg = str.view_from("could not infer type for an item without a source position");
            util.report_internal_error(msg);
            return Result.Error;
        }

        util.report_simple(e.ErrorKind.CouldNotInfer, *declared_at);
        return Result.Error;
    }

    return Result.OK;
}

def (ctx: *TyCtx) close_scope(): Result {
    let result = Result.OK;

    // this 'collapses' undecided types
    // If we encounter anyInt types, they will be converted to i32
    let current = ctx.values.top();
    for let i: usize = 0; i < current.bindings.len(); i += 1 {
        let bound = current.bindings.get_ptr_idx(i) as *scope.BoundItem;
        result = result.or(ctx.perform_item_close(bound.ty, bound.declared_at));

        // this check is only needed for real identifiers. Expression statements may be unsized
        // e.g. a call to some f(): void. And arguments will have been checked against the function
        // type already
        // TODO(#28): implement proper errors for unsized types
        if bound.ty.is_unsized() {
            util.report_internal_error_span(str.view_from("unsized bound"), *bound.declared_at);
            result = Result.Error;
        }

        if bound.ty.kind == TypeKind.Error {
            result = Result.Error;
        }
    }

    for let i: usize = 0; i < current.temp_vars.len; i += 1 {
        let bound = current.temp_vars.get_ptr(i) as *scope.BoundItem;
        result = result.or(ctx.perform_item_close(bound.ty, bound.declared_at));

        if bound.ty.kind == TypeKind.Error {
            result = Result.Error;
        }

        if bound.ty.kind == TypeKind.Function {
            let f = &bound.ty.data.function;
            let current = f.params_head;
            while current != null {
                // TODO(#36): get the source position for params/return
                result = result.or(ctx.perform_item_close(current.value, null));
                current = current.next;
            }

            result = result.or(ctx.perform_item_close(f.ret, null));
            // push the initialized function type into the original instance list
            // this might look confusing at first, but each function definition has a list of
            // instances. For normal functions, this list will only contain a single entry, but
            // for templated functions (generic function) this list might have an arbitrary
            // amount of different instances. The instance list internally works like a set
            f.instances.push(bound.ty);
        }
    }

    ctx.values.close();
    ctx.types.close();

    return result;
}

def (ctx: *TyCtx) alloc_ty(): *Type {
    return ctx.ty_arena.alloc() as *Type;
}

def (ctx: *TyCtx) alloc_node(): *TypeNode {
    return ctx.node_arena.alloc() as *TypeNode;
}

// a type variable to any
def (ctx: *TyCtx) any_var(): *Type {
    let anyTy = ctx.alloc_ty();
    anyTy.kind = TypeKind.Any;

    let var = ctx.alloc_ty();
    var.kind = TypeKind.Variable;
    var.data.inner = anyTy;
    return var;
}

// a type variable to anyInt
def (ctx: *TyCtx) any_var_int(): *Type {
    let anyIntTy = ctx.alloc_ty();
    anyIntTy.kind = TypeKind.AnyInt;

    let var = ctx.alloc_ty();
    var.kind = TypeKind.Variable;
    var.data.inner = anyIntTy;
    return var;
}

def (ctx: *TyCtx) any_var_float(): *Type {
    let anyFloatTy = ctx.alloc_ty();
    anyFloatTy.kind = TypeKind.AnyFloat;

    let var = ctx.alloc_ty();
    var.kind = TypeKind.Variable;
    var.data.inner = anyFloatTy;
    return var;
}

def (ctx: *TyCtx) error_type(): *Type {
    let error = ctx.alloc_ty();
    error.kind = TypeKind.Error;
    return error;
}

def (ctx: *TyCtx) get_current_function(): *function.Function {
    if ctx.current_function == null {
        return null;
    }
    return &ctx.current_function.data.function;
}

def lookup_in(name: str.View, stack: *scope.ScopeStack): *Type {
    let item: scope.BoundItem = undefined;
    if stack.lookup(name, &item).is_error() {
        return null;
    }

    return item.ty;
}

def (ctx: *TyCtx) lookup_type(name: str.View): *Type {
    return lookup_in(name, &ctx.types);
}

def (ctx: *TyCtx) lookup_value(name: str.View): *Type {
    return lookup_in(name, &ctx.values);
}

def (ctx: *TyCtx) lookup_tyid(ty: *tyid.Type): *Type {
    if ty.kind == tyid.TypeKind.Ptr {
        let ptr = ctx.alloc_ty();
        ptr.kind = TypeKind.Ptr;

        let inner = ctx.lookup_tyid(ty.inner());
        if inner == null {
            return null;
        }
        ptr.data.ptr_to = inner;
        return ptr;
    }

    let p = &ty.data.path;
    dbg.assert(p.segments.len == 1, "TODO(#26): handle arbitrary tyid segments");

    return ctx.lookup_type(p.segment_at(0).as_view());
}

def bind_in(name: str.View, ty: *Type, vis: Visibility, stack: *scope.ScopeStack, declared_at: *span.Span) {
    let item = scope.BoundItem {
        ty: ty,
        vis: vis,
        declared_at: declared_at
    };
    stack.bind(name, item);
}

def (ctx: *TyCtx) bind_temp(ty: *Type, span: *span.Span) {
    let item = scope.BoundItem {
        ty: ty,
        vis: Visibility.Public,
        declared_at: span
    };
    ctx.values.top().temp_vars.push(&item as *void);
}

def (ctx: *TyCtx) bind_value_public(name: str.View, ty: *Type, declared_at: *span.Span) {
    bind_in(name, ty, Visibility.Public, &ctx.values, declared_at);
}

def (ctx: *TyCtx) bind_type_public(name: str.View, ty: *Type, declared_at: *span.Span) {
    bind_in(name, ty, Visibility.Public, &ctx.types, declared_at);
}

def (ctx: *TyCtx) unify(a: *Type, previous: *Type): *Type {
    if ctx.is_concrete_version_of(a, previous) {

        if previous.kind == TypeKind.Variable {
            if a.kind == TypeKind.Variable  {
                // otherwise we could have cycles
                if a != previous {
                    // point the innermost variable to a instead
                    *previous.var_innermost() = a;
                }
            } else {
                // "overwrite" the old value
                previous.data.inner.kind = TypeKind.Variable;
                previous.data.inner.data.inner = a;
            }
        }

        return a;
    }

    if ctx.is_less_concrete_version_of(a, previous) {

        if a.kind == TypeKind.Variable {
            if previous.kind == TypeKind.Variable {
                // otherwise we could have cycles
                if a != previous {
                    *a.var_innermost() = previous;
                }
            } else {
                // "overwrite" the old value
                a.data.inner.kind = TypeKind.Variable;
                a.data.inner.data.inner = previous;
            }
        }

        return previous;
    }

    let a = a.checked_var_innermost();
    let previous = previous.checked_var_innermost();

    if a.kind == TypeKind.Ptr && previous.kind == TypeKind.Ptr {
        let inner = ctx.unify(a.data.ptr_to, previous.data.ptr_to);
        if inner == null {
            return null;
        }

        a.data.ptr_to = inner;
        return a;
    }

    if a.equals(previous) {
        return a;
    }

    return null;
}

// checks if other is a less concrete version of t
def (ctx: *TyCtx) is_concrete_version_of(t: *Type, other: *Type): bool {
    while t.is_variable() {
        t = t.data.inner;
    }
    while other.is_variable() {
        other = other.data.inner;
    }

    return other.kind == TypeKind.Any
        || t.kind == TypeKind.Int && other.kind == TypeKind.AnyInt
        || t.kind == TypeKind.Float && other.kind == TypeKind.AnyFloat;
}

// checks if t is a less concrete version of other
def (ctx: *TyCtx) is_less_concrete_version_of(t: *Type, other: *Type): bool {
    while t.is_variable() {
        t = t.data.inner;
    }
    while other.is_variable() {
        other = other.data.inner;
    }

    return t.kind == TypeKind.Any
        || t.kind == TypeKind.AnyInt && other.kind == TypeKind.Int
        || t.kind == TypeKind.AnyFloat && other.kind == TypeKind.Float;
}

// this will get the actual function type for a callable type or null, if the types was not callable
// in the case of a template, it will initialize all generic parameters using the allocator
def (ctx: *TyCtx) get_function(t: *Type): *Type {
    if t.kind == TypeKind.Function {
        return t;
    }

    if t.kind == TypeKind.Template {
        let f = ctx.get_function(t.data.template.inner);
        if f == null {
            return null;
        }

        let map = ctx.monomorph_map(&t.data.template);
        defer map.free();

        let monomorphed = ctx.alloc_ty().init_func(t.data.template.instances);
        monomorphed.data.function = f.data.function;
        monomorphed.data.function.params_head = null;
        let monomorphed_f = &monomorphed.data.function;

        let current_read = f.data.function.params_head;
        let current_write = &monomorphed_f.params_head;

        while current_read != null {
            let monomorphed_param = ctx.replace_param_type(&map, current_read.value);

            let name = current_read.name.data.ident;
            let new_node = ctx.alloc_node().init_ident(name, monomorphed_param);
            *current_write = new_node;

            current_write = &(*current_write).next;
            current_read = current_read.next;
        }

        monomorphed_f.ret = ctx.replace_param_type(&map, monomorphed_f.ret);
        return monomorphed;
    }

    if t.kind == TypeKind.Variable {
        return ctx.get_function(t.data.inner);
    }

    return null;
}

def (ctx: *TyCtx) replace_param_type(monomorph_map: *map.Map, param: *Type): *Type {
    if param.kind == TypeKind.TemplateParam {
        let key = key_from_ident(param.data.template_param.name);
        let monomorphed = monomorph_map.get(key) as *Type;
        dbg.assert(monomorphed != null, "monomorphed is null");
        return monomorphed;
    }

    if param.kind == TypeKind.Ptr {
        let inner = ctx.replace_param_type(monomorph_map, param.data.ptr_to);
        let ptr = ctx.alloc_ty();
        ptr.kind = TypeKind.Ptr;
        ptr.data.ptr_to = inner;
        return ptr;
    }

    return param;
}

def (ctx: *TyCtx) monomorph_map(t: *template.Template): map.Map {
    let map = map.with_cap(t.num_params);
    let current = t.generics_head;
    while current != null {
        let param = current.value;
        let monomorphed = ctx.any_var();

        let key = key_from_ident(param.data.template_param.name);
        map.insert(key, monomorphed as *void);

        current = current.next;
    }
    return map;
}

