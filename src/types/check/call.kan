import ":std/str";
import ":error" as e;
import ":ast/expr" as _;

import "../ctx";
import "../types" as _;
import "../util" as _;

// this kinda works like a super class, so i think this name is intuitive
import "expr" as super;

def infer(ctx: *ctx.TyCtx, expr: *Expr): TyResult {
    let call = &expr.data.call;

    let callee = super.infer(ctx, call.callee);
    if callee.is_error() {
        return callee;
    }

    let func_ty = ctx.get_function(callee.ty);
    if func_ty == null {
        let ty_s = callee.ty.to_string();
        defer ty_s.free();
        report_str(e.ErrorKind.CallingNonFunction, call.callee.span, ty_s.view());
        return error();
    }

    let function = &func_ty.data.function;
    if function.num_params != call.num_args {
        report_int2(
            e.ErrorKind.WrongNumberOfArgs,
            expr.span,
            function.num_params as i64,
            call.num_args as i64
        );
        return error();
    }

    let param = function.params_head;
    let arg = call.args_head;
    while param != null {
        if super.check(ctx, &arg.value, param.value).is_error() {
            return error();
        }

        param = param.next;
        arg = arg.next;
    }

    // this is a very important special case
    // the lookup for identifiers includes a special case for templates. In the case of a template,
    // we wrap the actual template type in another type variable, just so we are able to do this.
    // Here we change the inferred callee type from the template type to the actual function type
    if callee.ty.kind == TypeKind.Variable && callee.ty.data.inner.kind == TypeKind.Template {
        callee.ty.data.inner = func_ty;
        ctx.bind_temp(callee.ty, &call.callee.span);
    }

    return ok(function.ret);
}
