import "../../std/dbg";
import "../../std/str";
import "../../cli/report";
import "../../error" as e;

import "../../ast/expr";
import "../../util" as _;
import "../../ast/stmt" as _;

import "../util";
import "../ctx" as _;
import "../types" as _;

import "expr" as tychk;

def check(ctx: *TyCtx, stmt: *Stmt): Result {
    if stmt.kind == StmtKind.Expr {
        let result = tychk.infer(ctx, &stmt.data.expr);
        if result.is_error() {
            return Result.Error;
        }

        // TODO(#11): we need to report stupid rvalues that cannot be inferred.
        //  maybe bind a fake temporary variable like this?
        //  maybe disallow ignoring expression values entirely?
        //  but tbf if you disallow implicit value discarding like this:
        //     _ = f();
        //  it doesn't really change anything, since we still need to track temporary variables
        if stmt.data.expr.kind != expr.ExprKind.Assign && stmt.data.expr.kind != expr.ExprKind.Ident {
            // convert this into an implicit assignment (at least in the eyes of the TyCtx)
            ctx.bind_temp(result.ty, &stmt.data.expr.span);
        }

        return Result.OK;
    }

    if stmt.kind == StmtKind.Block {
        let block = &stmt.data.block;
        let len = block.len();

        ctx.open_scope();
        let had_errors = false;
        for let i: usize = 0; i < len; i += 1 {
            let s = block.at(i);
            if check(ctx, s).is_error() {
                had_errors = true;
            }
        }
        ctx.close_scope();

        if had_errors {
            return Result.Error;
        }

        return Result.OK;
    }

    if stmt.kind == StmtKind.LocalVarDecl {
        let decl = &stmt.data.local;

        let inferred = tychk.infer(ctx, decl.value);
        // TODO(#19): bind special error type to avoid repeating error messages
        if inferred.is_error() {
            return Result.Error;
        }

        let ty = inferred.ty;

        if decl.ty != null {
            let expected = ctx.lookup_tyid(decl.ty);
            if expected == null {
                util.report_str(e.ErrorKind.UndeclaredType, decl.ty.span, decl.ty.span.as_view());
                return Result.Error;
            }

            let instance = tychk.try_unify(ctx, decl.value, inferred.ty, expected);
            if instance.is_error() {
                return Result.Error;
            }
            ty = instance.ty;
        }

        ctx.bind_value_public(decl.name.as_view(), ty, &decl.name.span);
        return Result.OK;
    }

    // TODO(#23): write test cases for return statements
    if stmt.kind == StmtKind.Return {
        if ctx.current_function == null {
            let msg = "a return statement outside a fuction should be a parse error";
            util.report_internal_error(str.view_from(msg));
            return Result.Error;
        }

        if stmt.data.ret == null {
            if ctx.get_current_function().ret.kind != TypeKind.Void {
                let expected = ctx.get_current_function().ret.to_string();
                defer expected.free();
                util.report_str2(
                    e.ErrorKind.WrongType,
                    stmt.span,
                    expected.view(),
                    str.view("no return value", 15)
                );
                return Result.Error;
            } else {
                return Result.OK;
            }
        }

        let value = tychk.check(ctx, stmt.data.ret, ctx.get_current_function().ret);
        if value.is_error() {
            return Result.Error;
        }

        return Result.OK;
    }

    util.report_internal_error(str.view_from("unhandled stmt kind"));
    return Result.Error;
}
