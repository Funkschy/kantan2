import "../../std/dbg";
import "../../std/str";
import "../../cli/report";
import "../../error" as e;

import "../../ast/expr";
import "../../util" as _;
import "../../ast/stmt" as _;

import "../util";
import "../ctx" as _;
import "../types" as _;

import "expr" as tychk;

def check(ctx: *TyCtx, stmt: *Stmt): Result {
    if stmt.kind == StmtKind.Expr {
        let result = tychk.infer(ctx, &stmt.data.expr);
        if result.is_error() {
            return Result.Error;
        }

        // TODO: we need to report stupid rvalues that cannot be inferred.
        //  maybe bind a fake temporary variable like this?
        //  maybe disallow ignoring expression values entirely?
        //  but tbf if you disallow implicit value discarding like this:
        //     _ = f();
        //  it doesn't really change anything, since we still need to track temporary variables
        if stmt.data.expr.kind != expr.ExprKind.Assign && stmt.data.expr.kind != expr.ExprKind.Ident {
            // convert this into an implicit assignment (at least in the eyes of the TyCtx)
            ctx.bind_temp(result.ty, &stmt.data.expr.span);
        }

        return Result.OK;
    }

    if stmt.kind == StmtKind.Block {
        let block = &stmt.data.block;
        let len = block.len();

        let had_errors = false;
        for let i: usize = 0; i < len; i += 1 {
            let s = block.at(i);
            if check(ctx, s).is_error() {
                had_errors = true;
            }
        }

        if had_errors {
            return Result.Error;
        }

        return Result.OK;
    }

    if stmt.kind == StmtKind.LocalVarDecl {
        let decl = &stmt.data.local;

        let inferred = tychk.infer(ctx, decl.value);
        // TODO: bind special error type to avoid repeating error messages
        if inferred.is_error() {
            return Result.Error;
        }

        let ty = inferred.ty;

        if decl.ty != null {
            let expected = ctx.lookup_tyid(decl.ty);
            if expected == null {
                util.report_str(e.ErrorKind.UndeclaredType, decl.ty.span, decl.ty.span.as_view());
                return Result.Error;
            }

            let instance = tychk.try_unify(ctx, decl.value, inferred.ty, expected);
            if instance.is_error() {
                return Result.Error;
            }
            ty = instance.ty;
        }

        ctx.bind_value_public(decl.name.as_view(), ty, &decl.name.span);
        return Result.OK;
    }

    dbg.assert(false, "Unhandled StmtKind");
    return Result.Error;
}
