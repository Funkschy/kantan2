import ":std/dbg";
import ":std/str";
import ":error" as e;

import ":ast/expr";
import ":util" as _;
import ":ast/stmt" as _;

import "../util";
import "../ctx" as _;
import "../types" as _;

import "expr" as tychk;

def check(ctx: *TyCtx, stmt: *Stmt): Result {
    if stmt.kind == StmtKind.Expr {
        let result = tychk.infer(ctx, &stmt.data.expr);
        if result.is_error() {
            return Result.Error;
        }

        return Result.OK;
    }

    if stmt.kind == StmtKind.Block {
        let block = &stmt.data.block;
        let len = block.len();

        ctx.open_scope();
        let had_errors = false;
        for let i: usize = 0; i < len; i += 1 {
            let s = block.at(i);
            if check(ctx, s).is_error() {
                had_errors = true;
            }
        }
        ctx.close_scope();

        if had_errors {
            return Result.Error;
        }

        return Result.OK;
    }

    if stmt.kind == StmtKind.LocalVarDecl {
        let decl = &stmt.data.local;
        // bind error type by default so that no follow up errors are later reported in case that
        // one of the following ifs fails
        ctx.bind_value_public(decl.name.as_view(), ctx.error_type(), &decl.name.span);

        let inferred = tychk.infer(ctx, decl.value);
        if inferred.is_error() {
            return Result.Error;
        }

        let ty = inferred.ty;

        if decl.ty != null {
            let expected = ctx.lookup_tyid(decl.ty);
            if expected == null {
                ctx.bind_value_public(decl.name.as_view(), ctx.error_type(), &decl.name.span);
                util.report_str(e.ErrorKind.UndeclaredType, decl.ty.span, decl.ty.span.as_view());
                return Result.Error;
            }

            let instance = tychk.try_unify(ctx, decl.value, inferred.ty, expected);
            if instance.is_error() {
                return Result.Error;
            }
            ty = instance.ty;
        }

        ctx.bind_value_public(decl.name.as_view(), ty, &decl.name.span);
        return Result.OK;
    }

    if stmt.kind == StmtKind.Return {
        if ctx.current_function == null {
            let msg = "a return statement outside a fuction should be a parse error";
            util.report_internal_error(str.view_from(msg));
            return Result.Error;
        }

        if stmt.data.ret == null {
            if ctx.get_current_function().ret.kind != TypeKind.Void {
                let expected = ctx.get_current_function().ret.to_string();
                defer expected.free();
                util.report_str2(
                    e.ErrorKind.WrongType,
                    stmt.span,
                    expected.view(),
                    str.view("no return value", 15)
                );
                return Result.Error;
            } else {
                return Result.OK;
            }
        }

        let current_function = ctx.get_current_function();
        if current_function == null {
            let msg = "return outside of function should be a parse error";
            util.report_internal_error(str.view_from(msg));
        }

        if current_function.ret.kind == TypeKind.Void {
            util.report_str2(
                e.ErrorKind.WrongType,
                stmt.data.ret.span,
                str.view("no return value", 15),
                stmt.data.ret.span.as_view()
            );
            return Result.Error;
        }

        let value = tychk.check(ctx, stmt.data.ret, ctx.get_current_function().ret);
        if value.is_error() {
            return Result.Error;
        }

        return Result.OK;
    }

    util.report_internal_error(str.view_from("unhandled stmt kind"));
    return Result.Error;
}
