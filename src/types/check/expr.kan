import ":error" as e;
import ":ast/expr" as _;

import "../ctx";
import "../util" as _;
import "../types" as _;

import "unary";
import "literal";

// An example of how the type checking/infering works:
// the following is program structure is implied:
//      type Vec[T] struct { elements: *T }
//      def [T] create(): Vec[T] {...};
//
// 1) let v = create(); // no type information was provided
//  from the return type of 'create', we know that 'v' has to be a Vec, but we don't know T
//
// 2) v.push(1);
//  we know that T has to be some kind of integer, so we can infer v to be Vec[anyInt]
//  this first infers the type of push to be (Vec[any]) -> void and the type of 1 to be anyInt
//  and then checks, if anyInt can be used as any. This is were the kantan typechecker behaves
//  different from other bidirectional typecheckers, since the check may actually change the type
//  which we check against
//
// 3) v.push(undefined); // this does not change anything, since undefined can be any type
// 4) let first = *v.values; // we can infer first to be of type anyInt
// 5) first = 2 as u32;
// since u32 is more concrete than anyInt, we know that first has to be of type u32 and therefore
// Vec.elements must be *u32, meaning that v has type Vec[u32]

// if an error occurs, it will be reported and the returned type will be error
def infer(ctx: *ctx.TyCtx, expr: *Expr): TyResult {
    if expr.kind == ExprKind.Literal {
        return literal.infer(ctx, expr);
    }

    if expr.kind == ExprKind.Ident {
        let name = expr.data.ident.name.as_view();
        let ty = ctx.lookup_value(name);
        if ty != null {
            expr.data.ident.ty = ty;
            return ok(ty);
        }

        report_str(e.ErrorKind.UndeclaredIdentifier, expr, name);
        return error();
    }

    if expr.kind == ExprKind.Assign {
        let assign = &expr.data.assign;

        let left = infer(ctx, assign.left);
        if left.is_error() {
            return left;
        }

        let right = check(ctx, assign.right, left.ty);
        if right.is_error() {
            return right;
        }

        return ok(right.ty);
    }

    if expr.kind == ExprKind.Unary {
        return unary.infer(ctx, expr);
    }

    return error();
}

def check(ctx: *ctx.TyCtx, expr: *Expr, expected: *Type): TyResult {
    let inferred = infer(ctx, expr);
    if inferred.is_error() {
        report_simple(e.ErrorKind.CouldNotInfer, expr);
        return error();
    }

    return try_unify(ctx, expr, inferred.ty, expected);
}

def try_unify(ctx: *ctx.TyCtx, expr: *Expr, inferred: *Type, expected: *Type): TyResult {
    let instance = ctx.unify(inferred, expected);
    if instance == null {
        let expected = expected.to_string();
        defer expected.free();
        let actual = inferred.to_string();
        defer actual.free();
        report_str_str(e.ErrorKind.WrongType, expr, expected.view(), actual.view());
        return error();
    }

    return ok(instance);
}
