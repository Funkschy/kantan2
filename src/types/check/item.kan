import ":std/dbg";
import ":std/str";
import ":util" as _;
import ":ast/item" as _;

import ":error" as e;

import "../util";
import "../ctx" as _;
import "../types" as _;

import "stmt" as tychk;

def check(ctx: *TyCtx, item: *Item): Result {
    if item.kind == ItemKind.FuncDef {
        let func_ty = ctx.lookup_value(item.name.as_view());
        if func_ty == null {
            util.report_str(e.ErrorKind.UndeclaredType, item.name.span, item.name.as_view());
            return Result.Error;
        }

        // templates are only checked on invocation
        if func_ty.is_template() {
            return Result.OK;
        }

        ctx.open_scope();
        // bind params
        let param = func_ty.data.function.params_head;
        while param != null {
            dbg.assert(param.name.kind == NameKind.Ident, "expected ident, not str.View");
            let name = &param.name.data.ident;
            ctx.bind_value_public(name.as_view(), param.value, &name.span);
            param = param.next;
        }

        ctx.current_function = func_ty;
        let result = tychk.check(ctx, &item.data.func_def.block_stmt);
        ctx.close_scope();

        return result;
    }

    dbg.assert(false, "Unhandled ItemKind");
    return Result.Error;
}
