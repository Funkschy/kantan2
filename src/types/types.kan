import ":std/str";
import ":std/map";
import ":std/alloc";
import ":source/ident";

import "info";
import "data";
import "function";
import "template";
import "primitive";
import "instances" as _;

type TypeKind enum {
    // the error type is bound to variables, whose initializers could not be inferred
    // this is used to swallow follow up errors (for undefined variables)
    Error,
    // only used during the finalize stage of typechecking and invalid otherwise. This is used
    // to separate the final types from temporary types, which will be dropped with their arena
    Moved,
    // only used to infer types during typechecking and illegal afterwards
    // this is basically just a wrapper around another type. When checking agains a variable type,
    // the type that this points to may be changed (just the pointer, not the real type)
    Variable,
    // constraint types, only used to infer types during typechecking and illegal afterwards
    Any, AnyInt, AnyFloat,
    // builtin primitives
    Int, Float, Ptr, Bool, Void,
    Template, TemplateParam,
    // Functions are anonymous, while Signatures also have a name
    Function, Signature,
    // Structs and Unions
    DataType
}

type Type struct {
    kind: TypeKind,
    width: info.Size,
    align: info.Size,
    data: TypeData
}

type TypeData union {
    inner: *Type,
    new_location: *Type, // used when kind == Moved
    int: primitive.Integer,
    float: primitive.Float,
    ptr_to: *Type, // the inner type
    template: template.Template,
    template_param: template.Param,
    function: function.Function
}

def (t: *Type) init_int(signedness: primitive.Signedness, width: info.Size) {
    t.kind = TypeKind.Int;
    t.data.int.signedness = signedness;
    t.width = t.align = width;
}

def (t: *Type) init_float(width: info.Size) {
    t.kind = TypeKind.Float;
    t.width = t.align = width;
}

def (t: *Type) init_ptr(inner: *Type) {
    t.kind = TypeKind.Ptr;
    t.data.ptr_to = inner;
    // TODO(#18): make this platform dependent
    t.width = t.align = info.size_bytes(8);
}

def (t: *Type) is_integer(): bool {
    return t.kind == TypeKind.AnyInt
        || t.kind == TypeKind.Int
        || t.kind == TypeKind.Variable && t.data.inner.is_integer();
}

def (t: *Type) is_number(): bool {
    return t.kind == TypeKind.AnyInt
        || t.kind == TypeKind.Int
        || t.kind == TypeKind.AnyFloat
        || t.kind == TypeKind.Float
        || t.kind == TypeKind.Variable && t.data.inner.is_number();
}

def (t: *Type) is_unsized(): bool {
    return t.kind == TypeKind.Void
        || t.kind == TypeKind.Variable && t.data.inner.is_unsized();
}

def (t: *Type) is_any(): bool {
    return t.kind == TypeKind.Any
        || t.kind == TypeKind.Variable && t.data.inner.is_any();
}

def (t: *Type) is_pointer(): bool {
    return t.kind == TypeKind.Ptr
        || t.kind == TypeKind.Variable && t.data.inner.is_pointer();
}

def (t: *Type) is_variable(): bool {
    return t.kind == TypeKind.Variable;
}

def (t: *Type) is_template(): bool {
    return t.kind == TypeKind.Template
        || t.kind == TypeKind.Variable && t.data.inner.is_template();
}

def (t: *Type) is_function_known_at_compile_time(): bool {
    return t.kind == TypeKind.Function && t.data.function.is_known_at_compile_time();
}

// this assumes that t is in fact a Variable. Otherwise this is undefined behaviour
def (t: *Type) var_innermost(): **Type {
    let inner = &t.data.inner;
    while (*inner).kind == TypeKind.Variable {
        inner = &(*inner).data.inner;
    }
    return inner;
}

// this does not assume anything
def (t: *Type) checked_var_innermost(): *Type {
    if t.kind == TypeKind.Variable {
        return *t.var_innermost();
    }
    return t;
}

def (t: *Type) var_innermost_var(): **Type {
    let inner = &t;
    while (*inner).data.inner.kind == TypeKind.Variable {
        inner = &(*inner).data.inner;
    }
    return inner;
}

def (t: *Type) checked_var_innermost_var(): *Type {
    if t.kind == TypeKind.Variable {
        return *t.var_innermost_var();
    }
    return t;
}

def (t: *Type) equals(other: *Type): bool {
    if t == other {
        return true;
    }

    if t == null || other == null {
        return false;
    }

    while t.kind == TypeKind.Variable {
        t = t.data.inner;
    }

    while other.is_variable() {
        other = other.data.inner;
    }


    if t.kind != other.kind {
        return false;
    }

    if t.kind == TypeKind.Ptr {
        return t.data.ptr_to.equals(other.data.ptr_to);
    }

    if t.kind == TypeKind.Int {
        return t.data.int.signedness == other.data.int.signedness && t.width.equals(other.width);
    }

    if t.kind == TypeKind.Float {
        return t.width.equals(other.width);
    }

    if t.kind == TypeKind.Any || t.kind == TypeKind.AnyInt
        || t.kind == TypeKind.AnyFloat || t.kind == TypeKind.Bool {
        return true;
    }

    return false;
}

def (t: *Type) to_string(): str.String {
    if t == null {
        return str.from("null");
    }

    if t.kind == TypeKind.Variable {
        let s = str.from("->");
        let inner = t.data.inner.to_string();
        s.push(inner.view());
        inner.free();
        return s;
    }

    if t.kind == TypeKind.Bool {
        return str.from("bool");
    }

    if t.kind == TypeKind.Void {
        return str.from("void");
    }

    if t.kind == TypeKind.AnyInt {
        return str.from("integer");
    }

    if t.kind == TypeKind.AnyFloat {
        return str.from("float");
    }

    if t.kind == TypeKind.Any {
        return str.from("$T");
    }

    if t.kind == TypeKind.Int {
        let s = str.from("");

        let prefix = 'u' - 12 * (t.data.int.is_signed() as i8);
        s.push(str.view(&prefix, 1));

        if t.width.is_platform_dependent() {
            s.push(str.view("size", 4));
            return s;
        }

        let width = str.i64_to_string(t.width.bits() as i64);
        defer width.free();
        s.push(width.view());

        return s;
    }

    if t.kind == TypeKind.Float {
        let s = str.from("f");

        let width = str.i64_to_string(t.width.bits() as i64);
        defer width.free();
        s.push(width.view());

        return s;
    }

    if t.kind == TypeKind.Ptr {
        let s = str.from("*");
        let inner = t.data.ptr_to.to_string();
        defer inner.free();
        s.push(inner.view());
        return s;
    }

    if t.kind == TypeKind.Function {
        let s = str.from("(");

        let param = t.data.function.params_head;
        while param != null {
            defer param = param.next;
            if param != t.data.function.params_head {
                s.push(str.view(", ", 2));
            }

            let param_s = param.value.to_string();
            s.push(param_s.view());
            param_s.free();
        }
        s.push(str.view(")", 1));

        s.push(str.view(" -> ", 4));
        if t.data.function.ret != null {
            let ret_s = t.data.function.ret.to_string();
            s.push(ret_s.view());
            ret_s.free();
        } else {
            s.push(str.view("void", 4));
        }

        return s;
    }

    let s = str.from("ERROR: ");
    let kind = str.i64_to_string(t.kind as i32 as i64);
    defer kind.free();
    s.push(kind.view());
    return s;
}

type NameKind enum {
    Ident, View
}

type Name struct {
    kind: NameKind,
    data: NameData
}

type NameData union {
    ident: ident.Ident,
    view: str.View
}

// equivalent to ExprNode, but with an additional name. Look at ExprNode for more info
type TypeNode struct {
    name: Name,
    value: *Type,
    next: *TypeNode // may be null
}

def (n: *TypeNode) init_ident(ident: ident.Ident, value: *Type): *TypeNode {
    n.name = Name {
        kind: NameKind.Ident,
        data: NameData { ident: ident }
    };

    n.value = value;
    n.next = null;
    return n;
}

def (t: *Type) init_func(name: ident.Ident, instances: *InstanceSet): *Type {
    t.kind = TypeKind.Function;
    t.width = t.align = info.unsized();
    t.data.function.name = name;
    t.data.function.num_params = 0;
    t.data.function.abi = function.ABI.Kantan;
    t.data.function.c_variadic = false;
    t.data.function.params_head = null;
    t.data.function.ret = null;
    t.data.function.instances = instances;
    return t;
}

def (t: *Type) init_template(
    inner: *Type,
    num_params: usize,
    generics_head: *TypeNode,
    instances: *InstanceSet
): *Type {
    t.kind = TypeKind.Template;
    t.width = t.align = info.unsized();
    t.data.template.num_params = num_params;
    t.data.template.inner = inner;
    t.data.template.generics_head = generics_head;
    t.data.template.instances = instances;
    return t;
}

def (t: *Type) init_template_param(name: ident.Ident): *Type {
    t.kind = TypeKind.TemplateParam;
    t.width = t.align = info.unsized();
    t.data.template_param.name = name;
    return t;
}
