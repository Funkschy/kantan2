import "../std/str";
import "../source/ident";

import "info";
import "data";
import "function";
import "primitive";

type TypeKind enum {
    // only used to infer types during typechecking and illegal afterwards
    // this is basically just a wrapper around another type. When checking agains a variable type,
    // the type that this points to may be changed (just the pointer, not the real type)
    Variable,
    // constraint types, only used to infer types during typechecking and illegal afterwards
    Any, AnyInt, AnyFloat,
    // builtin primitives
    Int, Float, Ptr, Bool,
    // a type parameter. E.g 'T' in type Vec[T] struct {...}
    Param,
    // Functions are anonymous, while Signatures also have a name
    Function, Signature,
    // Structs and Unions
    DataType
}

type Type struct {
    kind: TypeKind,
    width: info.Size,
    align: info.Size,
    data: TypeData
}

type TypeData union {
    inner: *Type,
    int: primitive.Integer,
    float: primitive.Float,
    ptr_to: *Type, // the inner type
    function: function.Function
}

def (t: *Type) init_int(signedness: primitive.Signedness, width: info.Size) {
    t.kind = TypeKind.Int;
    t.data.int.signedness = signedness;
    t.width = t.align = width;
}

def (t: *Type) init_float(width: info.Size) {
    t.kind = TypeKind.Float;
    t.width = t.align = width;
}

def (t: *Type) init_ptr(inner: *Type) {
    t.kind = TypeKind.Ptr;
    t.data.ptr_to = inner;
    // TODO: make this platform dependent
    t.width = t.align = info.size_bytes(8);
}

def (t: *Type) is_integer(): bool {
    return t.kind == TypeKind.AnyInt
        || t.kind == TypeKind.Int
        || t.kind == TypeKind.Variable && t.data.inner.is_integer();
}

def (t: *Type) is_number(): bool {
    return t.kind == TypeKind.AnyInt
        || t.kind == TypeKind.Int
        || t.kind == TypeKind.AnyFloat
        || t.kind == TypeKind.Float
        || t.kind == TypeKind.Variable && t.data.inner.is_number();
}

def (t: *Type) is_any(): bool {
    return t.kind == TypeKind.Any
        || t.kind == TypeKind.Variable && t.data.inner.is_any();
}

def (t: *Type) is_pointer(): bool {
    return t.kind == TypeKind.Ptr
        || t.kind == TypeKind.Variable && t.data.inner.is_pointer();
}

// this will get the actual function type for a callable type or null, if the types was not callable
def (t: *Type) get_function(): *Type {
    if t.kind == TypeKind.Function {
        return t;
    }

    if t.kind == TypeKind.Variable {
        return t.data.inner.get_function();
    }

    return null;
}

def (t: *Type) is_concrete_version_of(other: *Type): bool {
    while t.is_variable() {
        t = t.data.inner;
    }
    while other.is_variable() {
        other = other.data.inner;
    }

    return other.kind == TypeKind.Any
        || t.kind == TypeKind.Int && other.kind == TypeKind.AnyInt
        || t.kind == TypeKind.Float && other.kind == TypeKind.AnyFloat;
}

def (t: *Type) is_less_concrete_version_of(other: *Type): bool {
    while t.is_variable() {
        t = t.data.inner;
    }
    while other.is_variable() {
        other = other.data.inner;
    }

    return t.kind == TypeKind.Any
        || t.kind == TypeKind.AnyInt && other.kind == TypeKind.Int
        || t.kind == TypeKind.AnyFloat && other.kind == TypeKind.Float;
}

def (t: *Type) is_variable(): bool {
    return t.kind == TypeKind.Variable;
}

def (t: *Type) equals(other: *Type): bool {
    if t == other {
        return true;
    }

    if t == null || other == null {
        return false;
    }

    while t.kind == TypeKind.Variable {
        t = t.data.inner;
    }

    while other.is_variable() {
        other = other.data.inner;
    }


    if t.kind != other.kind {
        return false;
    }

    if t.kind == TypeKind.Ptr {
        return t.data.ptr_to.equals(other.data.ptr_to);
    }

    if t.kind == TypeKind.Int {
        return t.data.int.signedness == other.data.int.signedness && t.width.equals(other.width);
    }

    if t.kind == TypeKind.Float {
        return t.width.equals(other.width);
    }

    if t.kind == TypeKind.Any || t.kind == TypeKind.AnyInt
        || t.kind == TypeKind.AnyFloat || t.kind == TypeKind.Bool {
        return true;
    }

    return false;
}

def (t: *Type) to_string(): str.String {
    if t == null {
        return str.from("null");
    }

    if t.kind == TypeKind.Variable {
        let s = str.from("->");
        let inner = t.data.inner.to_string();
        s.push(inner.view());
        inner.free();
        return s;
    }

    if t.kind == TypeKind.Bool {
        return str.from("bool");
    }

    if t.kind == TypeKind.AnyInt {
        return str.from("integer");
    }

    if t.kind == TypeKind.AnyFloat {
        return str.from("float");
    }

    if t.kind == TypeKind.Any {
        return str.from("$T");
    }

    // TODO: we probably want a special case here for usize/isize
    if t.kind == TypeKind.Int {
        let s = str.from("");

        let prefix = 'u' - 12 * (t.data.int.is_signed() as i8);
        s.push(str.view(&prefix, 1));

        if t.width.is_platform_dependent() {
            s.push(str.view("size", 4));
            return s;
        }

        let width = str.i64_to_string(t.width.bits() as i64);
        defer width.free();
        s.push(width.view());

        return s;
    }

    if t.kind == TypeKind.Float {
        let s = str.from("f");

        let width = str.i64_to_string(t.width.bits() as i64);
        defer width.free();
        s.push(width.view());

        return s;
    }

    if t.kind == TypeKind.Ptr {
        let s = str.from("*");
        let inner = t.data.ptr_to.to_string();
        defer inner.free();
        s.push(inner.view());
        return s;
    }

    if t.kind == TypeKind.Function {
        let s = str.from("(");

        let param = t.data.function.params_head;
        while param != null {
            defer param = param.next;
            if param != t.data.function.params_head {
                s.push(str.view(", ", 2));
            }

            let param_s = param.value.to_string();
            s.push(param_s.view());
            param_s.free();
        }
        s.push(str.view(")", 1));

        s.push(str.view(" -> ", 4));
        let ret_s = t.data.function.ret.to_string();
        s.push(ret_s.view());
        ret_s.free();

        return s;
    }

    let s = str.from("ERROR: ");
    let kind = str.i64_to_string(t.kind as i32 as i64);
    defer kind.free();
    s.push(kind.view());
    return s;
}

type NameKind enum {
    Ident, View
}

type Name struct {
    kind: NameKind,
    data: NameData
}

type NameData union {
    ident: ident.Ident,
    view: str.View
}

// equivalent to ExprNode, but with an additional name. Look at ExprNode for more info
type TypeNode struct {
    name: Name,
    value: *Type,
    next: *TypeNode // may be null
}

def (n: *TypeNode) init_ident(ident: ident.Ident): *TypeNode {
    n.name = Name {
        kind: NameKind.Ident,
        data: NameData { ident: ident }
    };

    n.value = null;
    n.next = null;
    return n;
}

def (t: *Type) init_func(): *Type {
    t.kind = TypeKind.Function;
    t.width = t.align = info.unsized();
    t.data.function.num_params = 0;
    t.data.function.abi = function.ABI.Kantan;
    t.data.function.c_variadic = false;
    t.data.function.params_head = null;
    t.data.function.ret = null;
    return t;
}

// this is the declared type parameter
// e.g. for
//   type Struct[T] struct {}
// T would be this parameter with the index 0 and name 'T'
type TypeParam struct {
    index: u32,
    name: ident.Ident
}
